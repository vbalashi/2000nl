name: Deploy to nuc

on:
  push:
    branches: [main]

concurrency:
  group: deploy-nuc
  cancel-in-progress: true

jobs:
  deploy:
    runs-on: self-hosted
    env:
      TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
      TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
      DEPLOY_SERVER_NAME: NUC (2000.dilum.io)
    steps:
      - name: Deploy with Telegram notifications
        shell: bash
        run: |
          set -euo pipefail

          send_telegram() {
            local message="$1"
            if [[ -z "${TELEGRAM_BOT_TOKEN:-}" || -z "${TELEGRAM_CHAT_ID:-}" ]]; then
              echo "Telegram env not set; skipping notification."
              return 0
            fi

            curl -fsSL -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
              --data-urlencode "chat_id=${TELEGRAM_CHAT_ID}" \
              --data-urlencode "text=${message}" \
              --data-urlencode "disable_web_page_preview=true" >/dev/null || true
          }

          DEPLOY_START=$(date +%s)
          START_TS_HUMAN=$(date -u '+%Y-%m-%d %H:%M:%S UTC')
          START_TS_ISO=$(date -u '+%Y-%m-%dT%H:%M:%SZ')

          cd /srv/2000nl-ui
          git fetch origin main

          VERSION=$(git show origin/main:apps/ui/package.json | node -p "JSON.parse(require('fs').readFileSync(0,'utf8')).version")
          COMMIT=$(git rev-parse --short origin/main)
          COMMIT_FULL=$(git rev-parse origin/main)

          # Provide build metadata to the Docker build so the UI and /api/health can show it.
          export NEXT_PUBLIC_APP_COMMIT="${COMMIT_FULL}"
          export NEXT_PUBLIC_BUILD_TIMESTAMP="${START_TS_ISO}"
          BUILD_ID=$(date -u '+%Y%m%dT%H%M%SZ')
          export NEXT_PUBLIC_APP_VERSION="${VERSION}+${BUILD_ID}.${COMMIT}"

          send_telegram "$(printf '%s\nTime: %s\nVersion: %s\nCommit: %s\nServer: %s' \
            'üöÄ Deployment started' \
            "${START_TS_HUMAN}" \
            "${NEXT_PUBLIC_APP_VERSION}" \
            "${COMMIT}" \
            "${DEPLOY_SERVER_NAME}")"

          on_err() {
            local status=$?
            local duration=$(( $(date +%s) - DEPLOY_START ))
            local end_ts_human
            end_ts_human=$(date -u '+%Y-%m-%d %H:%M:%S UTC')

            send_telegram "$(printf '%s\nTime: %s\nVersion: %s\nCommit: %s\nServer: %s\nDuration: %ss\nError: exit %s while running: %s' \
              '‚ùå Deployment failed' \
              "${end_ts_human}" \
              "${NEXT_PUBLIC_APP_VERSION}" \
              "${COMMIT}" \
              "${DEPLOY_SERVER_NAME}" \
              "${duration}" \
              "${status}" \
              "${BASH_COMMAND}")"
            exit "${status}"
          }
          trap on_err ERR

          git reset --hard origin/main

          # The runner service may start without updated supplementary groups.
          # `sg docker` ensures access to /var/run/docker.sock via the docker group.
          sg docker -c 'docker compose up -d --build'
          sg docker -c 'docker image prune -f'

          trap - ERR
          duration=$(( $(date +%s) - DEPLOY_START ))
          END_TS_HUMAN=$(date -u '+%Y-%m-%d %H:%M:%S UTC')
          send_telegram "$(printf '%s\nTime: %s\nVersion: %s\nCommit: %s\nServer: %s\nDuration: %ss' \
            '‚úÖ Deployment succeeded' \
            "${END_TS_HUMAN}" \
            "${NEXT_PUBLIC_APP_VERSION}" \
            "${COMMIT}" \
            "${DEPLOY_SERVER_NAME}" \
            "${duration}")"
